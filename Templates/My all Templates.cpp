{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
			"Random No. Generator between l to r": {
		"prefix": "random",
		"body": [
			"int64_t rand_int(int64_t l, int64_t r)",
			"{",
			"    static std::random_device rd;",
			"    static thread_local std::mt19937_64 gen(rd());",
			"    std::uniform_int_distribution<int64_t> dist(l, r);",
			"    return dist(gen);",
			"}",
			""
		],
		"description": ""
		},

				"this is mo's algorithm": {
		"prefix": "Mo's",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"",
			"template <class T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <class T>",
			"using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"// ------------------------- Mo's Algorithm Template -------------------------",
			"",
			"const int MAXN = 1e5 + 5; // Increase if needed",
			"int BLOCK;",
			"",
			"struct Query {",
			"    int l, r, idx;",
			"};",
			"",
			"int a[MAXN];        // Input array",
			"int answer[MAXN];   // Stores answers for queries",
			"int freq[MAXN];     // Frequency of elements",
			"",
			"// ------------------------ Choose Use Case ------------------------",
			"",
			"// Case 1: Count of elements with frequency exactly equal to their value",
			"int current_answer = 0;",
			"",
			"void add(int x) {",
			"    if (x >= MAXN) return;",
			"    if (freq[x] == x) current_answer--;",
			"    freq[x]++;",
			"    if (freq[x] == x) current_answer++;",
			"}",
			"",
			"void remove(int x) {",
			"    if (x >= MAXN) return;",
			"    if (freq[x] == x) current_answer--;",
			"    freq[x]--;",
			"    if (freq[x] == x) current_answer++;",
			"}",
			"",
			"/*",
			"// Case 2: Count of distinct elements in range",
			"int current_answer = 0;",
			"",
			"void add(int x) {",
			"    if (++freq[x] == 1) current_answer++;",
			"}",
			"",
			"void remove(int x) {",
			"    if (--freq[x] == 0) current_answer--;",
			"}",
			"*/",
			"",
			"/*",
			"// Case 3: Sum of elements in the range",
			"int current_answer = 0;",
			"",
			"void add(int x) {",
			"    current_answer += x;",
			"}",
			"",
			"void remove(int x) {",
			"    current_answer -= x;",
			"}",
			"*/",
			"",
			"/*",
			"// Case 4: Maximum frequency of any element in the range",
			"int current_answer = 0;",
			"int freq_bucket[MAXN];",
			"",
			"void add(int x) {",
			"    freq_bucket[freq[x]]--;",
			"    freq[x]++;",
			"    freq_bucket[freq[x]]++;",
			"    current_answer = max(current_answer, freq[x]);",
			"}",
			"",
			"void remove(int x) {",
			"    freq_bucket[freq[x]]--;",
			"    if (freq[x] == current_answer && freq_bucket[freq[x]] == 0)",
			"        current_answer--;",
			"    freq[x]--;",
			"    freq_bucket[freq[x]]++;",
			"}",
			"*/",
			"",
			"void mo_algorithm(int n, vector<Query> &queries)",
			"{",
			"    sort(all(queries), [&](const Query &a, const Query &b)",
			"         {",
			"    int block_a = a.l / BLOCK;",
			"    int block_b = b.l / BLOCK;",
			"    if (block_a != block_b)",
			"        return block_a < block_b;",
			"    return (block_a & 1) ? (a.r < b.r) : (a.r > b.r); });",
			"",
			"    int l = 0, r = -1;",
			"    for (auto q : queries)",
			"    {",
			"        while (l > q.l)",
			"            add(a[--l]);",
			"        while (r < q.r)",
			"            add(a[++r]);",
			"        while (l < q.l)",
			"            remove(a[l++]);",
			"        while (r > q.r)",
			"            remove(a[r--]);",
			"        answer[q.idx] = current_answer;",
			"    }",
			"}",
			"",
			"",
			"// ------------------------- Solve Function -------------------------",
			"",
			"void solve() {",
			"    int n, q;",
			"    cin >> n >> q;",
			"    BLOCK = sqrt(n);",
			"",
			"    for (int i = 0; i < n; i++)",
			"        cin >> a[i];",
			"",
			"    vector<Query> queries(q);",
			"    for (int i = 0; i < q; i++) {",
			"        cin >> queries[i].l >> queries[i].r;",
			"        queries[i].l--, queries[i].r--; // Convert to 0-based indexing",
			"        queries[i].idx = i;",
			"    }",
			"",
			"    mo_algorithm(n, queries);",
			"",
			"    for (int i = 0; i < q; i++)",
			"        cout << answer[i] << '\\n';",
			"}",
			"",
			"// ------------------------- Main -------------------------",
			"",
			"int32_t main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"    int t = 1;",
			"    // cin >> t;",
			"    while (t--) {",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": ""
		},
			"This is toposort code": {
		"prefix": "toposort",
		"body": [
			"vector<int> g[26]; // Adjust size based on problem constraints",
			"vector<int> topo_order;",
			"int used[26];",
			"",
			"void dfs(int v) {",
			"    used[v] = 1;",
			"    for (auto to : g[v]) {",
			"        if (used[to] == 1) { // Cycle detected",
			"            cout << \"Impossible\\n\";",
			"            exit(0);",
			"        } ",
			"        else if (used[to] == 0) {",
			"            dfs(to);",
			"        }",
			"    }",
			"    used[v] = 2;",
			"    topo_order.push_back(v);",
			"}",
			"",
			"vector<int> toposort(int n) {",
			"    fill(used, used + n, 0);",
			"    topo_order.clear();",
			"    for (int i = 0; i < n; i++) {",
			"        if (!used[i]) {",
			"            dfs(i);",
			"        }",
			"    }",
			"    reverse(topo_order.begin(), topo_order.end());",
			"    return topo_order;",
			"}",
			""
		],
		"description": ""
		},

			"topo_dfs": {
		"prefix": "topo_dfs",
		"body": [
			"",
			"vector<int> vis(n+1, 0);           // 0 = unvisited, 1 = visiting, 2 = visited",
			"bool hasCycle = false;",
			"",
			"function<void(int)> dfs = [&](int node) {",
			"    vis[node] = 1;",
			"    for (int nei : adj[node]) {",
			"        if (vis[nei] == 0) {",
			"            dfs(nei);",
			"        } else if (vis[nei] == 1) {",
			"            hasCycle = true; ",
			"            return;",
			"        }",
			"    }",
			"    vis[node] = 2;",
			"};",
			""
		],
		"description": ""
		},

			"lemda_function": {
		"prefix": "lemda",
		"body": [
			"function<bool(int)> ok= [&](int mid) -> bool {",
			"    return a + b;",
			"};",
			""
		],
		"description": ""
		
			},
				"Lowest common ancester": {
		"prefix": "lca",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp> ",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define pb push_back",
			"#define ff first",
			"#define ss second",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"",
			"template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"template <class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"const int M = 20;",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;",
			"",
			"    vector<vector<int>> adj(n + 1);",
			"    vector<int> dep(n + 1);",
			"    vector<vector<int>> Par(n + 1, vector<int>(M));",
			"",
			"    for (int i = 1; i < n; i++) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        adj[u].pb(v);",
			"        adj[v].pb(u);",
			"    }",
			"",
			"    function<void(int, int)> dfs = [&](int cur, int par) -> void {",
			"        dep[cur] = dep[par] + 1;",
			"        Par[cur][0] = par;",
			"        for (int j = 1; j < M; j++)",
			"            Par[cur][j] = Par[Par[cur][j - 1]][j - 1];",
			"        for (auto x : adj[cur])",
			"            if (x != par) dfs(x, cur);",
			"    };",
			"",
			"    function<int(int, int)> lca = [&](int u, int v) -> int {",
			"        if (u == v) return u;",
			"        if (dep[u] < dep[v]) swap(u, v);",
			"        int diff = dep[u] - dep[v];",
			"        for (int j = M - 1; j >= 0; j--)",
			"            if ((diff >> j) & 1)",
			"                u = Par[u][j];",
			"        for (int j = M - 1; j >= 0; j--) {",
			"            if (Par[u][j] != Par[v][j]) {",
			"                u = Par[u][j];",
			"                v = Par[v][j];",
			"            }",
			"        }",
			"        return (u!=v ? Par[u][0] : u );",
			"    };",
			"",
			"    dfs(1, 0); // assuming root is 1",
			"",
			"    // Example usage:",
			"    // int q; cin >> q;",
			"    // while (q--) {",
			"    //     int u, v;",
			"    //     cin >> u >> v;",
			"    //     cout << lca(u, v) << '\\n';",
			"    // }",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"    int t = 1;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": ""
		},
				"segment tree": {
		"prefix": "seg",
		"body": [
			"class Node {",
			"    public:",
			"    int len;",
			"    int ans;",
			"",
			"    Node() : len(1), ans(0) {};",
			"    Node(int val) : len(1), ans(val) {};",
			"};",
			"",
			"Node combine(Node &a, Node &b) {",
			"    Node c;",
			"    c.len = a.len + b.len;",
			"    c.ans = a.ans + b.ans;",
			"    return c;",
			"}",
			"",
			"void build(vector<Node> &tree, vector<int> &a, int n) {",
			"    for (int i = 0; i < n; i++) {",
			"        tree[i + n] = Node(a[i]);",
			"    }",
			"    for (int i = n - 1; i > 0; i--) {",
			"        tree[i] = combine(tree[(i << 1)], tree[(i << 1 | 1)]);",
			"    }",
			"}",
			"",
			"Node query(vector<Node> &tree, int n, int l, int r) {",
			"    Node ansl, ansr;",
			"    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
			"        if (l & 1) {",
			"            ansl = combine(ansl, tree[l]);",
			"            l += 1;",
			"        }",
			"        if (r & 1) {",
			"            r -= 1;",
			"            ansr = combine(tree[r], ansr);",
			"        }",
			"    }",
			"    return combine(ansl, ansr);",
			"}",
			"",
			"void update(vector<Node> &tree, int n, int p, int v) {",
			"    tree[p += n] = Node(v);",
			"    while (p >>= 1) {",
			"        tree[p] = combine(tree[(p << 1)], tree[(p << 1 | 1)]);",
			"    }",
			"}",
			"",
			"Node query(vector<Node> &tree, int n, int p) {",
			"    Node ans;",
			"    for (p += n; p > 0; p >>= 1) {",
			"        ans = combine(ans, tree[p]);",
			"    }",
			"    return ans;",
			"}",
			"",
			"void update(vector<Node> &tree, int n, int l, int r, int v) {",
			"    Node temp = Node(v);",
			"    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
			"        if (l & 1) {",
			"            tree[l] = combine(tree[l], temp);",
			"            l += 1;",
			"        } else {",
			"            r -= 1;",
			"            tree[r] = combine(tree[r], temp);",
			"        }",
			"    }",
			"}",
			"",
			"void push(vector<Node> &tree, int n) {",
			"    for (int i = 1; i < n; i++) {",
			"        tree[(i << 1)] = combine(tree[(i << 1)], tree[i]);",
			"        tree[(i << 1 | 1)] = combine(tree[(i << 1 | 1)], tree[i]);",
			"        tree[i] = Node();",
			"    }",
			"}"
		],
		"description": ""
		},

				"point Update and Point+Range query": {
		"prefix": "BIT-1",
		"body": [
			"const int MAXN = 1e6 + 5;",
			"",
			"int BIT[MAXN]; // Binary Indexed Tree",
			"",
			"// Point Update: Add 'value' to index 'index'",
			"void update(int index, int value) {",
			"    while (index < MAXN) {",
			"        BIT[index] += value;",
			"        index += index & -index;",
			"    }",
			"}",
			"",
			"// Prefix Sum Query: Get sum from 1 to 'index'",
			"int query(int index) {",
			"    int res = 0;",
			"    while (index > 0) {",
			"        res += BIT[index];",
			"        index -= index & -index;",
			"    }",
			"    return res;",
			"}",
			"",
			"int range_sum(int l, int r) {",
			"    return sum(r) - sum(l - 1);",
			"}",
			""
		],
		"description": ""
		},

				"Range Update, Point Query": {
		"prefix": "BIT-2",
		"body": [
			"const int MAXN = 1e6 + 5;",
			"",
			"int BIT[MAXN]; // Binary Indexed Tree (1-based indexing)",
			"",
			"void update(int index, int value) {",
			"    while (index < MAXN) {",
			"        BIT[index] += value;",
			"        index += index & -index;",
			"    }",
			"}",
			"",
			"void range_update(int l, int r, int value) {",
			"    update(l, value);",
			"    update(r + 1, -value);",
			"}",
			"",
			"int query(int index) {",
			"    int res = 0;",
			"    while (index > 0) {",
			"        res += BIT[index];",
			"        index -= index & -index;",
			"    }",
			"    return res;",
			"}",
			""
		],
		"description": ""
		},
		"Range Update, Range Query": {
		"prefix": "BIT-3",
		"body": [
			"const int MAXN = 1e6 + 5;",
			"",
			"int BIT1[MAXN]; // Coefficient tree",
			"int BIT2[MAXN]; // Compensation tree",
			"",
			"void update_BIT(int BIT[], int index, int value) {",
			"    while (index < MAXN) {",
			"        BIT[index] += value;",
			"        index += index & -index;",
			"    }",
			"}",
			"",
			"void range_update_sum(int l, int r, int x) {",
			"    update_BIT(BIT1, l, x);",
			"    update_BIT(BIT1, r + 1, -x);",
			"    update_BIT(BIT2, l, x * (l - 1));",
			"    update_BIT(BIT2, r + 1, -x * r);",
			"}",
			"",
			"int prefix_query(int BIT[], int index) {",
			"    int res = 0;",
			"    while (index > 0) {",
			"        res += BIT[index];",
			"        index -= index & -index;",
			"    }",
			"    return res;",
			"}",
			"",
			"int prefix_sum_range(int index) {",
			"    return prefix_query(BIT1, index) * index - prefix_query(BIT2, index);",
			"}",
			"",
			"int range_sum_query(int l, int r) {",
			"    return prefix_sum_range(r) - prefix_sum_range(l - 1);",
			"}",
			""
		],
		"description": ""
		},
				"FenwickTree ": {
		"prefix": "BIT",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp> ",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define  ff first",
			"#define  ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"template <class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"struct FenwickTree {",
			"    int n;",
			"    vector<int> bit;      // For point update, prefix/range query",
			"    vector<int> bitAdd;   // For range update, point query",
			"    vector<int> bitAdd1;  // For range update, range query",
			"    vector<int> bitAdd2;  // For range update, range query",
			"",
			"    FenwickTree(int _n) {",
			"        n = _n + 2;",
			"        bit.assign(n, 0);",
			"        bitAdd.assign(n, 0);",
			"        bitAdd1.assign(n, 0);",
			"        bitAdd2.assign(n, 0);",
			"    }",
			"",
			"    FenwickTree(vector<int> &a) : FenwickTree(a.size()) {",
			"        for (int i = 0; i < (int)a.size(); i++)",
			"            update(i, a[i]);",
			"    }",
			"",
			"    // --------- 1. Point Update, Range Query ----------",
			"    void update(int idx, int delta) {",
			"        for (++idx; idx < n; idx += idx & -idx)",
			"            bit[idx] += delta;",
			"    }",
			"",
			"    int sum(int idx) {",
			"        int result = 0;",
			"        for (++idx; idx > 0; idx -= idx & -idx)",
			"            result += bit[idx];",
			"        return result;",
			"    }",
			"",
			"    int rangeSum(int l, int r) {",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"",
			"    // --------- 2. Range Update, Point Query ----------",
			"    void update(int idx, int delta) {",
			"        for (++idx; idx < n; idx += idx & -idx)",
			"            bitAdd[idx] += delta;",
			"    }",
			"",
			"    void rangeUpdate(int l, int r, int delta) {",
			"        update(l, delta);",
			"        update(r + 1, -delta);",
			"    }",
			"",
			"    int sum(int idx) {",
			"        int res = 0;",
			"        for (++idx; idx > 0; idx -= idx & -idx)",
			"            res += bitAdd[idx];",
			"        return res;",
			"    }",
			"",
			"    // --------- 3. Range Update, Range Query ----------",
			"    void internalAdd(vector<int> &b, int idx, int val) {",
			"        while (idx < n) {",
			"            b[idx] += val;",
			"            idx += idx & -idx;",
			"        }",
			"    }",
			"",
			"    void rangeUpdateRangeQuery(int l, int r, int val) {",
			"        internalAdd(bitAdd1, l + 1, val);",
			"        internalAdd(bitAdd1, r + 2, -val);",
			"        internalAdd(bitAdd2, l + 1, val * (l));",
			"        internalAdd(bitAdd2, r + 2, -val * (r + 1));",
			"    }",
			"",
			"    int internalSum(const vector<int> &b, int idx) {",
			"        int result = 0;",
			"        while (idx > 0) {",
			"            result += b[idx];",
			"            idx -= idx & -idx;",
			"        }",
			"        return result;",
			"    }",
			"",
			"    int prefixRangeQuery(int idx) {",
			"        idx++;",
			"        return internalSum(bitAdd1, idx) * idx - internalSum(bitAdd2, idx);",
			"    }",
			"",
			"    int rangeQuery(int l, int r) {",
			"        return prefixRangeQuery(r) - prefixRangeQuery(l - 1);",
			"    }",
			"};",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;",
			"    vector<int> v(n);",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        cin >> v[i];",
			"    }",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"    int t=1;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"   return 0;",
			"}"
		],
		"description": ""
		},	

			"DisJointSetUnion1": {
		"prefix": "DSU",
		"body": [
			"class UnionFind",
			"{",
			"    private: vector<int> p, rank;",
			"    public:",
			"",
			"        UnionFind(int n)",
			"        {",
			"            rank.assign(n,0); p.assign(n,0);",
			"            iota(p.begin(),p.end(),0);",
			"        }",
			"",
			"        int findSet(int i){ return (p[i] == i) ? i : p[i] = findSet(p[i]);}",
			"",
			"        bool isSameSet(int i, int j){ return findSet(i) == findSet(j);}",
			"",
			"        void unionSet(int i, int j)",
			"        {",
			"            if(!isSameSet(i,j))",
			"            {",
			"                int x = findSet(i), y = findSet(j);",
			"                if(rank[x] > rank[y]) p[y] = x;",
			"                else ",
			"                {",
			"                    p[x] = y;",
			"                    if(rank[x] == rank[y]) rank[y]++;",
			"                }",
			"            }",
			"        }",
			"};"
		],
		"description": ""
		},

				"This is second dsu code snippet": {
		"prefix": "DSU2",
		"body": [
			"struct DSU {",
			"    vector<int> parent, size;",
			"    int components;",
			"",
			"    DSU(int n) {",
			"        parent.resize(n);",
			"        size.assign(n, 1);",
			"        iota(parent.begin(), parent.end(), 0);",
			"        components = n;",
			"    }",
			"",
			"    // Find representative with path compression",
			"    int find(int u) {",
			"        return parent[u] == u ? u : parent[u] = find(parent[u]);",
			"    }",
			"",
			"    // Union by size",
			"    bool unite(int u, int v) {",
			"        u = find(u);",
			"        v = find(v);",
			"        if (u == v) return false;",
			"        if (size[u] < size[v]) swap(u, v);",
			"        parent[v] = u;",
			"        size[u] += size[v];",
			"        components--;",
			"        return true;",
			"    }",
			"",
			"    // Get size of component where u belongs",
			"    int getSize(int u) {",
			"        return size[find(u)];",
			"    }",
			"",
			"    // Check if u and v are in the same set",
			"    bool same(int u, int v) {",
			"        return find(u) == find(v);",
			"    }",
			"",
			"    // Get total number of components",
			"    int countComponents() {",
			"        return components;",
			"    }",
			"};",
			""
		],
		"description": ""
		},

				"Persistent DSU": {
		"prefix": "DSU_Rollback",
		"body": [
			"struct RollbackDSU {",
			"    vector<int> parent, size;",
			"    stack<pair<int, int>> history;  // {node changed, previous parent or size}",
			"    int components;",
			"",
			"    RollbackDSU(int n) {",
			"        parent.resize(n);",
			"        size.assign(n, 1);",
			"        iota(parent.begin(), parent.end(), 0);",
			"        components = n;",
			"    }",
			"",
			"    int find(int u) {",
			"        while (u != parent[u]) u = parent[u];",
			"        return u;",
			"    }",
			"",
			"    bool unite(int u, int v) {",
			"        u = find(u);",
			"        v = find(v);",
			"        if (u == v) return false;",
			"        if (size[u] < size[v]) swap(u, v);",
			"",
			"        // Save state before change",
			"        history.push({v, parent[v]});",
			"        history.push({u, size[u]});",
			"",
			"        parent[v] = u;",
			"        size[u] += size[v];",
			"        components--;",
			"        return true;",
			"    }",
			"",
			"    void rollback() {",
			"        if (history.empty()) return;",
			"        auto [u, sz_u] = history.top(); history.pop();",
			"        auto [v, par_v] = history.top(); history.pop();",
			"",
			"        size[u] = sz_u;",
			"        parent[v] = par_v;",
			"        components++;",
			"    }",
			"",
			"    int getSize(int u) {",
			"        return size[find(u)];",
			"    }",
			"",
			"    int countComponents() {",
			"        return components;",
			"    }",
			"",
			"    void reset() {",
			"        while (!history.empty()) rollback();",
			"    }",
			"};",
			"",
			"// It’s a DSU where you can undo previous union() operations. Useful in:",
			"",
			"// Divide and conquer on edges",
			"",
			"// Offline queries (like “what was the DSU at time T?”)",
			"",
			"// Problems where DSU state must revert to an earlier state"
		],
		"description": ""
		},


				"DSU on Tree (Small to Large Merge)": {
		"prefix": "DSU_TREES",
		"body": [
			"vector<int> adj[N];",
			"int cnt[N]; // or any info per node",
			"bool big[N];",
			"",
			"void dfs(int u, int p, bool keep) {",
			"    int mx = -1, bigChild = -1;",
			"",
			"    // 1. find biggest child",
			"    for (int v : adj[u]) {",
			"        if (v != p && sz[v] > mx) {",
			"            mx = sz[v];",
			"            bigChild = v;",
			"        }",
			"    }",
			"",
			"    // 2. process all small children",
			"    for (int v : adj[u]) {",
			"        if (v != p && v != bigChild) dfs(v, u, false);",
			"    }",
			"",
			"    // 3. process big child and keep its data",
			"    if (bigChild != -1) dfs(bigChild, u, true), big[bigChild] = true;",
			"",
			"    // 4. now add this node + all smalls",
			"    add(u, p, +1);",
			"",
			"    // ➤ Query result for this node here",
			"",
			"    if (bigChild != -1) big[bigChild] = false;",
			"    if (!keep) add(u, p, -1); // delete if not keeping",
			"}",
			"",
			"void add(int u, int p, int delta) {",
			"    cnt[color[u]] += delta;",
			"    for (int v : adj[u])",
			"        if (v != p && !big[v]) add(v, u, delta);",
			"}",
			"// DSU on Tree (Small to Large Merge)",
			"// 🧠 What Is It?",
			"// You're doing DFS on a tree, and you want to:",
			"",
			"// Track frequencies",
			"",
			"// Count how many nodes have some value in subtree",
			"",
			"// Answer queries on each node’s subtree",
			"",
			"// ❗Problem:",
			"// If you naively recompute info in every subtree, time = O(n²).",
			"",
			"// ✅ Idea: Merge small subtree into big one.",
			"// When DFS-ing a tree:",
			"",
			"// Identify the biggest child (by subtree size)",
			"",
			"// Process all small children first (and discard their info)",
			"",
			"// Process big child and keep its data",
			"",
			"// Merge smalls into big one",
			"",
			"// This keeps total work O(n log n) — because each node merges only into a bigger node a few times."
		],
		"description": ""
		},

			"Lazy Propagation": {
		"prefix": "lazy_propagation",
		"body": [
			"class node{",
			"    public:",
			"    int len,del,res;",
			"    node(int v){",
			"        len=1;",
			"        del=0;",
			"        res=v;",
			"    }",
			"};",
			"node compute(node a,node b,node c){",
			"    a.len=b.len+c.len;",
			"    a.res=b.res+c.res;",
			"    if(a.del==0) return a;",
			"    a.res=a.del*a.len;",
			"    return a;",
			"}",
			"void apply(vector<node> &tree,int n,int p,int v){",
			"    tree[p].res=v*tree[p].len;",
			"    if(p<n) tree[p].del=v;",
			"}",
			"void build(vector<node> &tree,vector<int> &a,int n){",
			"    for(int i=0;i<n;i++){",
			"        tree[i+n]=node(a[i]);",
			"    }",
			"    for(int i=n-1;i>0;i--){",
			"        tree[i]=compute(tree[i],tree[i<<1],tree[i<<1|1]);",
			"    }",
			"}",
			"void pull(vector<node> &tree,int p){",
			"    while(p>>=1) tree[p]=compute(tree[p],tree[p<<1],tree[p<<1|1]);",
			"}",
			"void push(vector<node> &tree,int n,int p){",
			"    for(int s=log2(n);s>0;s--){",
			"        int i=p>>s;",
			"        if(tree[i].del==0) continue;",
			"        apply(tree,n,i<<1,tree[i].del);",
			"        apply(tree,n,i<<1|1,tree[i].del);",
			"        tree[i].del=0;        ",
			"    }",
			"}",
			"void update(vector<node> &tree,int n,int l,int r,int v){",
			"    if(v==0) return;",
			"    int left=l+n,right=r+n;",
			"    push(tree,n,left);",
			"    push(tree,n,right-1);",
			"    for(l+=n,r+=n;l<r;l>>=1,r>>=1){",
			"        if(l&1) apply(tree,n,l++,v);",
			"        if(r&1) apply(tree,n,--r,v);",
			"    }",
			"    pull(tree,left);",
			"    pull(tree,right-1);",
			"}",
			"node query(vector<node> &tree,int n,int l,int r){",
			"    int left=l+n,right=r+n;",
			"    push(tree,n,left);",
			"    push(tree,n,right-1);",
			"    node resl(0),resr(0);",
			"    for(l+=n,r+=n;l<r;l>>=1,r>>=1){",
			"        if(l&1) resl=compute(resl,resl,tree[l++]);",
			"        if(r&1) resr=compute(resr,tree[--r],resr);",
			"    }",
			"    return compute(resl,resl,resr);",
			"}"
		],
		"description": ""
		},
			"lexicographically largest subsequence ": {
		"prefix": "getLongestSubseq",
		"body": [
			"string getSubSeq(string s, int n, vector<int>& a) {",
			"    string res = \"\";",
			"    char c = s[n - 1];",
			"    res += c;",
			"    a.push_back(n - 1);",
			"",
			"    for (int i = n - 2; i >= 0; i--) {",
			"        if (s[i] >= c) {",
			"            c = s[i];",
			"            res += c;",
			"            a.push_back(i);",
			"        }",
			"    }",
			"    reverse(res.begin(), res.end());",
			"    reverse(a.begin(), a.end());",
			"",
			"    return res;",
			"}"
		],
		"description": ""
		},
			"check prime ": {
		"prefix": "is_prime",
		"body": [
			"bool isPrime(int n) {",
			"    if (n <= 1) return false;",
			"    if (n <= 3) return true;",
			"    if (n % 2 == 0 || n % 3 == 0) return false;",
			"",
			"    for (int i = 5; i * i <= n; i += 6) {",
			"        if (n % i == 0 || n % (i + 2) == 0) return false;",
			"    }",
			"",
			"    return true;",
			"}"
		],
		"description": ""
		},
		"String Hashing": {
		"prefix": "string_hash",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"#define ordered_set tree<long long, null_type, less<long long>, rb_tree_tag, tree_order_statistics_node_update>",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			// "int binaryexponentiation(int a, int b, int m)",
			// "{",
			// "    int ans = 1;",
			// "    while (b)",
			// "    {",
			// "        if (b & 1)",
			// "        {",
			// "            ans = (1LL * ans * a) % m;",
			// "        }",
			// "        a = (1LL * a * a) % m;",
			// "        b >>= 1;",
			// "    }",
			// "    return ans % m;",
			// "}",
			// "int mminvprime(int a, int m)",
			// "{",
			// "    return binaryexponentiation(a, m - 2, m);",
			// "}",
			// "int mod_mul(int a, int b, int m)",
			// "{",
			// "    return ((a % m) * (b % m)) % m;",
			// "}",
			// "int mod_sub(int a, int b, int m)",
			// "{",
			// "    return (a % m - b % m + m) % m;",
			// "}",
			"",
			"const int M = 1e9 + 7;",
			"const int BASE1 = 5689;",
			"const int BASE2 = 8861;",
			"",
			"struct Hash",
			"{",
			"    vector<pair<int, int>> hashes, po;",
			"    Hash(string s)",
			"    {",
			"        hashes.assign(s.size() + 1, {1, 1});",
			"        po.assign(s.size() + 1, {1, 1});",
			"        for (int i = 0; i < (int)(s.size()); i++)",
			"        {",
			"            hashes[i + 1] = {(hashes[i].first * BASE1 + ((s[i] - 'a') + 1)) % M,",
			"                             (hashes[i].second * BASE2 + ((s[i] - 'a') + 1)) % M};",
			"            po[i + 1] = {(po[i].first * BASE1) % M,",
			"                         (po[i].second * BASE2) % M};",
			"        }",
			"    }",
			"",
			"    pair<int, int> get(int l, int r)",
			"    {",
			"        l++, r++;",
			"        int hash1 = (hashes[r].first - (hashes[l - 1].first * po[r - l + 1].first) % M + M) % M;",
			"        int hash2 = (hashes[r].second - (hashes[l - 1].second * po[r - l + 1].second) % M + M) % M;",
			"        return {hash1, hash2};",
			"    }",
			"};",
			// "struct Hashing",
			// "{",
			// "    string s;",
			// "    int n;",
			// "    int primes;",
			// "    vector<int> hashPrimes = {1000000009, 100000007};",
			// "    const int base = 31;",
			// "    vector<vector<int>> hashValues;",
			// "    vector<vector<int>> powersOfBase;",
			// "    vector<vector<int>> inversePowersOfBase;",
			// "    Hashing(string a)",
			// "    {",
			// "        primes = (hashPrimes).size();",
			// "        hashValues.resize(primes);",
			// "        powersOfBase.resize(primes);",
			// "        inversePowersOfBase.resize(primes);",
			// "        s = a;",
			// "        n = s.length();",
			// "        for (int i = 0; i < (hashPrimes).size(); i++)",
			// "        {",
			// "            powersOfBase[i].resize(n + 1);",
			// "            inversePowersOfBase[i].resize(n + 1);",
			// "            powersOfBase[i][0] = 1;",
			// "            for (int j = 1; j <= n; j++)",
			// "            {",
			// "                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];",
			// "            }",
			// "            inversePowersOfBase[i][n] = mminvprime(powersOfBase[i][n], hashPrimes[i]);",
			// "            for (int j = n - 1; j >= 0; j--)",
			// "            {",
			// "                inversePowersOfBase[i][j] = mod_mul(inversePowersOfBase[i][j + 1], base, hashPrimes[i]);",
			// "            }",
			// "        }",
			// "        for (int i = 0; i < (hashPrimes).size(); i++)",
			// "        {",
			// "            hashValues[i].resize(n);",
			// "            for (int j = 0; j < n; j++)",
			// "            {",
			// "                hashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];",
			// "                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];",
			// "            }",
			// "        }",
			// "    }",
			// "    vector<int> substringHash(int l, int r)",
			// "    {",
			// "        vector<int> hash(primes);",
			// "        for (int i = 0; i < primes; i++)",
			// "        {",
			// "            int val1 = hashValues[i][r];",
			// "            int val2 = l > 0 ? hashValues[i][l - 1] : 0LL;",
			// "            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), inversePowersOfBase[i][l], hashPrimes[i]);",
			// "        }",
			// "        return hash;",
			// "    }",
			// "};",
			"",
			"void solve()",
			"{",
			"    // Type code here$1",
			"",
			"    ",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"    int t = 1;",
			"    // cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}"
		],
	"description": ""
	},
		"kadanes Algorithm for max": {
		"prefix": "Kadanes",
		"body": [
			"int max_subarray_sum(vector<int> &a)",
			"{",
			"    int maxi = 0, curr = 0;",
			"    for (auto x : a)",
			"    {",
			"        curr = max(0LL, curr + x);",
			"        maxi = max(maxi, curr);",
			"    }",
			"    return maxi;",
			"}"
		],
		"description": ""
		},

		"kadanes Algorithm for min": {
		"prefix": "Kadanes_min",
		"body": [
			"int min_subarray_sum(vector<int> &a) {",
			"    int mini = 0, curr = 0;",
			"    for (auto x : a) {",
			"        curr = min(0LL, curr + x);",
			"        mini = min(mini, curr);",
			"    }",
			"    return mini;",
			"}",
			""
		],
		"description": ""
		},
		
	"Picks Algorithm": {
	"prefix": "picks_algo",
	"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define unsigned long long ull",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"struct Point",
			"{",
			"    int x, y;",
			"};",
			"",
			"// Function to calculate the greatest common divisor (GCD)",
			"int gcd(int a, int b)",
			"{",
			"    return b == 0 ? a : gcd(b, a % b);",
			"}",
			"",
			"// Function to calculate the boundary points of the polygon",
			"int boundaryPoints(const vector<Point> &points)",
			"{",
			"    int n = points.size();",
			"    int boundary_points = 0;",
			"    for (int i = 0; i < n; ++i)",
			"    {",
			"        Point p1 = points[i];",
			"        Point p2 = points[(i + 1) % n];",
			"        int dx = abs(p1.x - p2.x);",
			"        int dy = abs(p1.y - p2.y);",
			"        boundary_points += gcd(dx, dy);",
			"    }",
			"    return boundary_points;",
			"}",
			"",
			"// Function to calculate the signed area of the polygon",
			"int signedArea(const vector<Point> &points)",
			"{",
			"    int n = points.size();",
			"    int area = 0;",
			"    for (int i = 0; i < n; ++i)",
			"    {",
			"        Point p1 = points[i];",
			"        Point p2 = points[(i + 1) % n];",
			"        area += (p1.x * p2.y) - (p2.x * p1.y);",
			"    }",
			"    return area;",
			"}",
			"",
			"// Function to calculate the interior points of the polygon using Pick's Theorem",
			"int interiorPoints(const vector<Point> &points)",
			"{",
			"    int boundary_points = boundaryPoints(points);",
			"    int area = abs(signedArea(points));",
			"    return (area - boundary_points + 2) / 2;",
			"}",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;",
			"    vector<Point> polygon(n);",
			"    for (int i = 0; i < n; ++i)",
			"    {",
			"        cin >> polygon[i].x >> polygon[i].y;",
			"    }",
			"    int interior_points = interiorPoints(polygon);",
			"    cout << \"Number of interior points: \" << interior_points << endl;",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"    int t=1;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": ""
	},
	"factorial_Modulo": {
		"prefix": "mod_fact",
		"body": [
			"int mod_fact(int n, int m) {",
			"    int result = 1;",
			"    for (int i = 1; i <= n; ++i) {",
			"        result = (result *1LL* i) % m;",
			"    }",
			"    return result;",
			"}"
		],
		"description": ""
		},
	"Moduler Inverse": {
		"prefix": "mminvprime",
		"body": [
			"int mminvprime(int a, int m)",
		  "{",
		  "    return binaryexponentiation(a, m - 2, m);",
		  "}",
		  "",
		],
		"description": ""
		},
	"Moduler Multiplication": {
		"prefix": "mod_mul",
		"body": [
			"int mod_mul(int a, int b, int m) {",
			"    return ((a % m) * (b % m)) % m;",
			"}",
			""
		],
		"description": ""
		},
	"Moduler Subtraction": {
		"prefix": "mod_sub",
		"body": [
			"int mod_sub(int a, int b, int m) {",
			"    return (a % m - b % m + m) % m;",
			"}",
			""
		],
		"description": ""
		},
	"Moduler addition": {
		"prefix": "mod_add",
		"body": [
			"int mod_add(int a, int b, int m) {",
			"    return (a % m + (b+m) % m) % m;",
			"}",
			""
		],
		"description": ""
		},

			"Prime Factorization using SPF": {
		"prefix": "prime_fact",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"template <class T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <class T>",
			"using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"const int maxN = 1e6;",
			"vector<int> spf(maxN, 1e9); // Smallest prime factor",
			"",
			"vector<pair<int, int>> primeFactorization(int x)",
			"{",
			"    vector<pair<int, int>> ans;",
			"    while (x != 1)",
			"    {",
			"        int prime = spf[x];",
			"        int cnt = 0;",
			"        while (x % prime == 0)",
			"        {",
			"            cnt++;",
			"            x = x / prime;",
			"        }",
			"        ans.push_back({prime, cnt});",
			"    }",
			"    return ans;",
			"    //log(x)",
			"}",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;",
			"",
			"    vector<pair<int, int>> factors = primeFactorization(n);",
			"    ",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"",
			"    // Precompute smallest prime factors",
			"    vector<bool> isPrime(maxN, true);",
			"    for (long long i = 2; i < maxN; i++)",
			"    {",
			"        if (isPrime[i])",
			"        {",
			"            spf[i] = i;",
			"            for (long long j = i * i; j < maxN; j += i)",
			"            {",
			"                isPrime[j] = false;",
			"                spf[j] = min(spf[j], (int)i);",
			"            }",
			"        }",
			"    }",
			"    //N*loglog(N)",
			"",
			"    int t = 1;",
			"    cin >> t;$0",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": ""
		},

			"Smallest prime factor": {
		"prefix": "spf",
		"body": [
			"const int N = 1e6 + 1;",
			"vector<bool> isPrime(N, true);",
			"vector<int> spf(N);",
			"",
			"void initSieve()",
			"{",
			"    isPrime[0] = false, isPrime[1] = false;",
			"    iota(spf.begin(), spf.end(), 0);",
			"    for (int i = 2; i <= N; i++)",
			"    {",
			"        if (isPrime[i])",
			"        {",
			"            for (int j = i * i; j <= N; j += i)",
			"            {",
			"                isPrime[j] = false;",
			"                spf[j] = min(spf[j], i);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"initSieve(); // call this in main function",
		],
		"description": ""
		},
		"Euler's Totient function": {
		"prefix": "phi",
		"body": [
			"vector<int> phi_1_to_n(int n) {",
			"    vector<int> phi(n + 1);",
			"    for (int i = 0; i <= n; i++)",
			"        phi[i] = i;",
			" ",
			"    for (int i = 2; i <= n; i++) {",
			"        if (phi[i] == i) {",
			"            for (int j = i; j <= n; j += i)",
			"                phi[j] -= phi[j] / i;",
			"        }",
			"    }",
			" ",
			"    return phi;",
			"}"
		],
		"description": ""
		},
		"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const int N = 100;",
			"vector<int> primes;",
			"void sieve(int N, vector<int>& primes) {",
			"    vector<bool> isPrime(N + 1, true);",
			"    isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers",
			"",
			"    for (int p = 2; p * p <= N; ++p) {",
			"        if (isPrime[p]) {",
			"            for (int i = p * p; i <= N; i += p)",
			"                isPrime[i] = false;",
			"        }",
			"    }",
			"",
			"    for (int i = 2; i <= N; ++i) {",
			"        if (isPrime[i]) {",
			"            primes.push_back(i);",
			"        }",
			"    }",
			"}"
		],
		"description": ""
		},
	"nCr for small n and r": {
		"prefix": "mini_nCr",
		"body": [
		  "int nCr(int n, int r)",
		  "{",
		  "    if (r > n)",
		  "    {",
		  "        return 0;",
		  "    }",
		  "    if (r == 0 || r == n)",
		  "    {",
		  "        return 1;",
		  "    }",
		  "    if (r > n - r)",
		  "    { // Since C(n, r) == C(n, n - r)",
		  "        r = n - r;",
		  "    }",
		  "",
		  "    int result = 1;",
		  "    for (int i = 0; i < r; ++i)",
		  "    {",
		  "        result *= (n - i);",
		  "        result /= (i + 1);",
		  "    }",
		  "",
		  "    return result;",
		  "}"
		],
		"description": ""
	  },
	"Z-FUNCTION": {
		"prefix": "z_function",
		"body": [
		  "vector<int> z_function(string s) {",
		  "    int n = s.size(), l = 0, r = 0;",
		  "    vector<int> z(n);",
		  "    for(int i = 1; i < n; i++) {",
		  "        if(i < r) z[i] = min(r - i, z[i - l]);",
		  "        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
		  "        if(i + z[i] > r) l = i, r = i + z[i];",
		  "    }",
		  "    return z;",
		  "}"
		],
		"description": ""
	  },
	"TREE ALRORITHM": {
		"prefix": "trees_algo",
		"body": [
		  "array<vector<int>, 2> bfs(int src, int n, vector<int> adj[]) {",
		  "    vector<int> dist(n + 1, -1);",
		  "    vector<int> from(n + 1, -1);",
		  "    queue<int> q;",
		  "",
		  "    dist[src] = 0;",
		  "    q.push(src);",
		  "",
		  "    while (!q.empty()) {",
		  "        int node = q.front();",
		  "        q.pop();",
		  "",
		  "        for (int child : adj[node]) if (dist[child] == -1) {",
		  "            dist[child] = dist[node] + 1;",
		  "            from[child] = node;",
		  "            q.push(child);",
		  "        }",
		  "    }",
		  "    ",
		  "    return {dist, from};",
		  "}",
		  "",
		  "pair<int,int> findDiameter(int n, vector<int> adj[]) {",
		  "    vector<int> dist1 = bfs(1, n, adj)[0];",
		  "    int node1 = max_element(dist1.begin(), dist1.end()) - dist1.begin();",
		  "    vector<int> dist2 = bfs(node1, n, adj)[0];",
		  "    int node2 = max_element(dist2.begin(), dist2.end()) - dist2.begin();",
		  "    return {node1, node2};",
		  "}",
		  "",
		  "vector<int> getPath(int src, int dest, int n, vector<int> adj[]) {",
		  "    auto [dist, from] = bfs(src, n, adj);",
		  "    vector<int> path;",
		  "    for (int node = dest; node != -1; node = from[node]) {",
		  "        path.push_back(node);",
		  "    }",
		  "    reverse(path.begin(), path.end());",
		  "    return path;",
		  "}"
		],
		"description": ""
	  },

	  "MANACHER ALGORITHM": {
	"prefix": "manacher",
	"body": [
		"#include <bits/stdc++.h>",
		"#include <ext/pb_ds/assoc_container.hpp>",
		"#include <ext/pb_ds/tree_policy.hpp>",
		"using namespace __gnu_pbds;",
		"using namespace std;",
		"",
		"#define int long long",
		"#define ull unsigned long long",
		"#define lld long double",
		"#define ff first",
		"#define ss second",
		"#define pb push_back",
		"#define ppb pop_back",
		"#define pf push_front",
		"#define ppf pop_front",
		"#define mp make_pair",
		"#define all(x) (x).begin(), (x).end()",
		"#define rall(x) (x).rbegin(), (x).rend()",
		"constexpr int L = 232792560;",
		"#define mod 1000000007",
		"template <class T>",
		"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
		"template <class T>",
		"using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
		"",
		"typedef priority_queue<long long> maxheap;",
		"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
		"",
		"// ---- MANACHER ALGORITHM STRUCT ----",
		"struct Manacher",
		"{",
		"    vector<int> p;",
		"    string t;",
		"",
		"    void run_manacher(const string &s)",
		"    {",
		"        int n = s.length();",
		"        p.assign(n, 1);",
		"        int l = 1, r = 1;",
		"",
		"        for (int i = 1; i < n; i++)",
		"        {",
		"            p[i] = max(0LL, min(r - i, p[l + r - i]));",
		"            while (i + p[i] < n && i - p[i] >= 0 && s[i + p[i]] == s[i - p[i]])",
		"            {",
		"                p[i]++;",
		"            }",
		"            if (i + p[i] > r)",
		"            {",
		"                l = i - p[i];",
		"                r = i + p[i];",
		"            }",
		"        }",
		"    }",
		"    void build(const string &s)",
		"    {",
		"        t = \"#\";",
		"        for (char c : s)",
		"        {",
		"            t += c;",
		"            t += \"#\";",
		"        }",
		"        run_manacher(t);",
		"    }",
		"",
		"    int getLongest(int cen, bool odd)",
		"    {",
		"        int pos = 2 * cen + 1 + (!odd);",
		"        return p[pos] - 1;",
		"    }",
		"",
		"    void print()",
		"    {",
		"        for (auto i : p)",
		"            cout << i << \" \";",
		"    }",
		"",
		"    string findmaxPalindrome()",
		"    {",
		"        int pos = -1, len = 0;",
		"",
		"        for (int i = 0; i < p.size(); i++)",
		"        {",
		"            if (p[i] > len)",
		"            {",
		"                len = p[i];",
		"                pos = i;",
		"            }",
		"        }",
		"",
		"        int start = pos - len + 1;",
		"        int end = pos + len - 1;",
		"",
		"        string res = \"\";",
		"        for (int i = start; i <= end; i++)",
		"        {",
		"            if (t[i] != '#')",
		"                res += t[i];",
		"        }",
		"",
		"        return res;",
		"    }",
		"",
		"    bool checkPalin(int l, int r)",
		"    {",
		"        int len = r - l + 1;",
		"        int cen = (l + r) / 2;",
		"        bool odd = (l % 2 == r % 2);",
		"        return getLongest(cen, odd) >= len;",
		"    }",
		"};",
		"",
		"// ---- DRIVER CODE ----",
		"void solve()",
		"{",
		"    string s;",
		"    cin >> s;",
		"    // int i = 0, n = s.size();",
		"    Manacher m;",
		"    m.build(s);",
		"    string pal = m.findmaxPalindrome();",
		"    cout << pal << endl;",
		"}",
		"",
		"int32_t main()",
		"{",
		"    ios_base::sync_with_stdio(false);",
		"    cin.tie(nullptr);",
		"    cout.tie(nullptr);",
		"#ifndef ONLINE_JUDGE",
		"    freopen(\"Error.txt\", \"w\", stderr);",
		"#endif",
		"    int t = 1;",
		"    // cin >> t;",
		"    while (t--)",
		"    {",
		"        solve();",
		"    }",
		"    return 0;",
		"}"
	],
	"description": ""
	},
	
	"KMP ALGORITHM": {
		"prefix": "KMP",
		"body": [
		  "// returns the pi function",
		  "// pi[i] = length of the longest proper prefix of the substring str[0...i] ",
		  "//         which is also a suffix of this substring",
		  "vector<int> prefix_function(string str) {",
		  "    int n = str.length();",
		  "    vector<int> pi(n, 0);",
		  "    for (int i = 1; i < n; i++) {",
		  "        int j = i - 1;",
		  "        while (j >= 0 && str[pi[j]] != str[i]) {",
		  "            j = pi[j] - 1;",
		  "        }",
		  "        if (j >= 0) pi[i] = pi[j] + 1;",
		  "    }",
		  "    return pi;",
		  "}",
		  "",
		  "// return the indexes of the occurrences of the pattern in the text",
		  "vector <int> search(string text, string pattern) {",
		  "    int n = text.length();",
		  "    int m = pattern.length();",
		  "    string str = pattern + \"#\" + text;",
		  "    vector<int> pi = prefix_function(str);",
		  "    vector<int> ans;",
		  "    for (int i = 2 * m; i <= n + m; i++) {",
		  "        if (pi[i] >= m) ans.push_back(i - 2 * m);",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": ""
	  },
	"Mint": {
		"prefix": "Mint",
		"body": [
		  "// const int MOD = 1e9 + 7;",
		  "// const int MOD = 998244353;",
		  "// const long long MOD = 1375927501846395853LL;",
		  "template<const int mod>",
		  "struct mint {",
		  "    int val;",
		  "    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}",
		  "    explicit operator int() const { return val; }",
		  "    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }",
		  "    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }",
		  "    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }",
		  "    mint& operator/=(const mint &b) { return *this *= b.inv(); }",
		  "    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }",
		  "    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }",
		  "    mint operator-() const { return val == 0 ? 0 : mod - val; }",
		  "    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }",
		  "    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }",
		  "    mint operator++(int32_t) { mint before = *this; ++*this; return before; }",
		  "    mint operator--(int32_t) { mint before = *this; --*this; return before; }",
		  "    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}",
		  "    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}",
		  "    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}",
		  "    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}",
		  "    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}",
		  "    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}",
		  "    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}",
		  "    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}",
		  "    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}",
		  "};",
		  "using Mint = mint<MOD>;"
		],
		"description": ""
	  },


			"This is the code for count inversion": {
		"prefix": "count_inversion",
		"body": [
			"int count_inversions(vector<int> &arr)",
			"{",
			"    int n = arr.size();",
			"    vector<int> temp(n);",
			"    function<int(int, int)> merge_sort = [&](int left, int right) -> int",
			"    {",
			"        if (left >= right)",
			"            return 0;",
			"        int mid = (left + right) / 2;",
			"        int inv = merge_sort(left, mid) + merge_sort(mid + 1, right);",
			"        int i = left, j = mid + 1, k = left;",
			"        while (i <= mid && j <= right)",
			"        {",
			"            if (arr[i] <= arr[j])",
			"                temp[k++] = arr[i++];",
			"            else",
			"            {",
			"                temp[k++] = arr[j++];",
			"                inv += mid - i + 1;",
			"            }",
			"        }",
			"        while (i <= mid)",
			"            temp[k++] = arr[i++];",
			"        while (j <= right)",
			"            temp[k++] = arr[j++];",
			"        for (int i = left; i <= right; ++i)",
			"            arr[i] = temp[i];",
			"        return inv;",
			"    };",
			"    return merge_sort(0, n - 1);",
			"}"
		],
		"description": ""
		},

	"Modular Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
		  "int binaryexponentiation(int a, int b, int m)",
		  "{",
		  "    int ans = 1;",
		  "    while (b)",
		  "    {",
		  "        if (b & 1)",
		  "        {",
		  "            ans = (1LL * ans * a) % m;",
		  "        }",
		  "        a = (1LL * a * a) % m;",
		  "        b >>= 1;",
		  "    }",
		  "    return ans % m;",
		  "}"
		],
		"description": ""
	  },
	"Basic code for ncr": {
		"prefix": "ncr",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "#define int long long",
		  "#define ull unsigned long long",
		  "#define ff first",
		  "#define ss second",
		  "#define pb push_back",
		  "#define ppb pop_back",
		  "#define pf push_front",
		  "#define ppf pop_front",
		  "#define mp make_pair",
		  "#define all(x) (x).begin(), (x).end()",
		  "#define rall(x) (x).rbegin(), (x).rend()",
		  "#define mod 1000000007",
		  "",
		  "vector<int> fact;",
		  "vector<int> ifact;",
		  "",
		  "int binaryexponentiation(int a, int b, int m)",
		  "{",
		  "    int ans = 1;",
		  "    while (b)",
		  "    {",
		  "        if (b & 1)",
		  "        {",
		  "            ans = (1LL * ans * a) % m;",
		  "        }",
		  "        a = (1LL * a * a) % m;",
		  "        b >>= 1;",
		  "    }",
		  "    return ans % m;",
		  "}",
		  "",
		  "int mod_mul(int a, int b, int m)",
		  "{",
		  "    return (1LL * a * b) % m;",
		  "}",
		  "",
		  "int mminvprime(int a, int m)",
		  "{",
		  "    return binaryexponentiation(a, m - 2, m);",
		  "}",
		  "",
		  "int combination(int n, int r, int m)",
		  "{",
		  "    if (r > n)",
		  "        return 0;",
		  "    return mod_mul(fact[n], mod_mul(ifact[r], ifact[n - r], m), m);",
		  "}",
		  "",
		  "void precompute_factorials(int n)",
		  "{",
		  "    fact.resize(n + 1);",
		  "    ifact.resize(n + 1);",
		  "    fact[0] = 1;",
		  "    for (int i = 1; i <= n; i++)",
		  "    {",
		  "        fact[i] = mod_mul(fact[i - 1], i, mod);",
		  "    }",
		  "    ifact[n] = mminvprime(fact[n], mod);",
		  "    for (int i = n - 1; i >= 0; i--)",
		  "    {",
		  "        ifact[i] = mod_mul(ifact[i + 1], i + 1, mod);",
		  "    }",
		  "    // cout << combination(8, 2, mod, fact, ifact) << endl;",
		  "}",
		  "",
		  "void solve()",
		  "{",
		  "    // type code$0",
		  "}",
		  "",
		  "int32_t main()",
		  "{",
		  "    ios_base::sync_with_stdio(false);",
		  "    cin.tie(nullptr);",
		  "    cout.tie(nullptr);",
		  "    precompute_factorials(1e6);",
		  "    int t = 1;",
		  "    cin >> t;",
		  "    while (t--)",
		  "    {",
		  "        solve();",
		  "    }",
		  "    return 0;",
		  "}",
		  ""
		],
		"description": ""
	  },
	
	"boilerplate": {
			"prefix": "debug",
			"body": [
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x << \" \" << x << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			// "void _print(ll t) { cerr << t; }",
			"void _print(int t) { cerr << t; }",
			"void _print(string t) { cerr << t; }",
			"void _print(char t) { cerr << t; }",
			"void _print(lld t) { cerr << t; }",
			"void _print(double t) { cerr << t; }",
			"void _print(ull t) { cerr << t; }",
			"",
			"template <class T, class V> void _print(pair <T, V> p);",
			"template <class T> void _print(vector <T> v);",
			"template <class T> void _print(set <T> v);",
			"template <class T, class V> void _print(map <T, V> v);",
			"template <class T> void _print(multiset <T> v);",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			],
			"description": "Log output to console"
		},

		"Ordered_set code": {
		"prefix": "ordered_set",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp> ",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define  ff first",
			"#define  ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"template <class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"int index(ordered_set<int> &st,int value){",
			"    return st.order_of_key(value);", // Finding the number of elements strictly less than value 
			"}",
			"int value(ordered_set<int> &st,int index){",
			"    return *st.find_by_order(index);", // It returns to an iterator to the kth element (counting from zero) in the set in O(logn) time.
			"}",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;$0",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"    int t=1;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"   return 0;",
			"}"
		],
		"description": ""
		},
		"interactive problem template": {
		"prefix": "interactive",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"",
			"template <class T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <class T>",
			"using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;",
			"    vector<int> v(n);",
			"    for (int &x : v) cin >> x; ",
			"    ",
			"    auto query = [&](int i, int j) -> int",
			"    {",
			"        cout << \"? \" << i << \" \" << j << endl;",
			"        int response;",
			"        cin >> response;",
			"        return response; ",
			"    };",
			"    ",
			"   // Example interaction logic (replace with actual problem logic)",
			"    int result = query(1, n);",
			"    cout << \"! \" << result << endl; ",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"Error.txt\", \"w\", stderr);",
			"#endif",
			"",
			"    int t = 1;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": ""
		},
	
	"CPP": {
		"prefix": "io",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp> ",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
            "#define int long long",
			"#define ull unsigned long long",
			"#define lld long double",
			"#define  ff first",
			"#define  ss second",
			"#define pb push_back",
			"#define ppb pop_back",
			"#define pf push_front",
			"#define ppf pop_front",
			"#define mp make_pair",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"constexpr int L = 232792560;",
			"#define mod 1000000007",
			"template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"template <class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"",
			"typedef priority_queue<long long> maxheap;",
			"typedef priority_queue<long long, vector<long long>, greater<long long>> minheap;",
			"",
			"void solve()",
			"{",
			"	int n;",
			"    cin >> n;",
			"    vector<int> v(n);",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        cin >> v[i];",
			"    }",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"#ifndef ONLINE_JUDGE",
    		"    freopen(\"Error.txt\", \"w\", stderr);",
    		"#endif",
			"    int t=1;",
			"    cin >> t;$0",
			"    while (t--)",
			"    {",
			"    	solve();",
			"    }",
			"   return 0;",
			"}"
			
		],
		"description": "Log output to console"
	}
}
